### 1. JVM内存区域

![JVM内存区域](/Users/wenzhuowang/Desktop/框图/JVM内存区域.png)

#### 1.1 heap区

https://blog.csdn.net/shiyong1949/article/details/52585256

##### 1.1.1 新生代

1个Eden区和2个Survivor区（分别叫from和to），默认比例为8：1。

##### 1.1.2 老年代

1. 存放新生代中经过多次垃圾回收仍然存活的对象
2. 存放新生代分配不了内存的大对象

##### 复制算法：

因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法。

复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

始终保持名为To的 survivor是空的。



#### 1.2 非heap区

**Java中的基本数据类型一定存储在栈中吗?**

不一定。栈内存用来存储局部变量和方法调用。

如果该局部变量是基本数据类型例如 `int a = 1;`, 那么直接将该值存储在栈中。

如果该局部变量是一个对象例如` int[] array=new int[]{1,2};`  那么将引用存在栈中而对象({1,2})存储在堆内。

**栈的速度比堆快吗**?

不一定，谁也不必谁快，速度不是本质的差异。



#### 1.3.  JVM运行时内存

概念上大致分为 6 个（逻辑）区域，注：Method Area 中还有一个常量池区，图中未明确标出。

![img](https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png)

上述 6 个区域，除了 PC Register 区不会抛出 StackOverflowError 或 OutOfMemoryError ，其它 5 个区域，当请求分配的内存不足时，均会抛出 OutOfMemoryError（即：OOM），其中 thread 独立的 JVM Stack 区及 Native Method Stack 区还会抛出 StackOverflowError。

这 6 块区域按是否被线程共享，可以分为两大类：

![img](https://static001.infoq.cn/resource/image/b4/62/b4ff890142874a6cbef1ad7a80eb7462.png)

##### 1.3.1 线程独享

![堆栈详解](/Users/wenzhuowang/Desktop/框图/堆栈详解.png)

**这 3 类区域，生命周期与 Thread 相同，即：线程创建时，相应的区域分配内存，线程销毁时，释放相应内存**

1）**PC Register**：也称为**程序计数器**， 记录每个线程当前执行的指令信。eg：当前执行到哪一条指令，下一条该取哪条指令。

2）**JVM Stack**：也称为**虚拟机栈**，记录每个栈帧（Frame）中的局部变量、方法返回地址等

线程中每次有方法调用时，会创建 Frame，方法调用结束时 Frame 销毁。

![img](https://static001.infoq.cn/resource/image/60/2e/60d744b2966293f16c481d5bd5ec482e.png)

3）**Native Method Stack**：**本地(原生)方法栈**，顾名思义就是调用操作系统原生本地方法时，所需要的内存区域。



##### 1.3.2 线程共享

Heap、Method Area 都是在虚拟机启动时创建，虚拟机退出时释放。

1）**Heap**：即鼎鼎大名的**堆**内存区，也是 GC 垃圾回收的主站场，用于存放类的实例对象及 Arrays 实例等。

2）**Method Area**：**方法区**，主要存放类结构、类成员定义，static 静态成员等。

3）**Runtime Constant Pool**：**运行时常量池**，比如：字符串，int -128~127 范围的值等，它是 Method Area 中的一部分。



### 2. 垃圾回收机制

#### 2.1 垃圾回收的过程

![垃圾回收(GC)](/Users/wenzhuowang/Desktop/框图/垃圾回收(GC).png)

一般情况下，新创建的对象都会被分配到Eden区。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。（p.s.**大对象直接进入老年代**，大对象就是需要**大量连续内存空间的对象**（比如：字符串、数组）。频繁复制降低性能。）

这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，old+1，当它的年龄增加到一定程度时（默认为 15 岁），就会被移动到老年代中。在老年代存满后，虚拟机进行Major GC。

#### 2.2 垃圾回收算法

![垃圾回收算法](/Users/wenzhuowang/Desktop/框图/垃圾回收算法.png)



#### 2.3 如何判断垃圾 (对象死亡)

![img](https://static001.infoq.cn/resource/image/1c/cb/1c91169ff735b21daa16d650700d3dcb.png)

![img](https://static001.infoq.cn/resource/image/92/73/92b436a2f1d92b1ff385ac99927ab573.png)

循环引用是否能GC回收

1. 引用计数算法：无法解决
2. 可达性算法：关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots 没有关联，则会被回收，否则将继续存活。

#### 2.4 垃圾收集器

##### 2.4.1 CMS

1）**初始标记 ** Inital Mark ：主要是<u>标记 GC Root 开始的下级（注：仅下一级）对象</u>，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。

2）**并发标记** Concurrent Mark ：根据上一步的结果，<u>继续向下标识所有关联的对象，直到这条链上的最尽头。</u>这个过程是**多线程**的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。

3）**再标志** Remark ：为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。

4）**并行清理** Concurrent Sweep ：这里使用多线程以“Mark Sweep-标记清理”算法，把垃圾清掉，其它工作线程仍然能继续支行，不会造成卡顿。



##### 2.4.2 G1

###### **优点**

- **将整个Java堆划分为多个大小相等的独立区域（Region）**，虽然还保留新生代和老年代的概念，但**新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合**
- 并行与并发： G1 能充分利用 **CPU、多核**环境下的硬件优势，使用多个 CPU来缩短 Stop-The-World 停顿时间。
- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合：G1 从整体来看是基于**“标记整理”**算法实现的收集器；从局部上来看是基于**“复制”算法**实现的。
- 可预测停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型。G1跟踪**各个Region里面的垃圾堆积的价值大小**（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region**。

###### **过程**

G1 将 heap 内存区，划分为一个个大小相等、内存连续的 Region 区域，每个 region 都对应 Eden、Survivor 、Old、Humongous 四种角色之一，但是 region 与 region 之间不要求连续。

注：Humongous，简称 H 区是专用于存放超大对象的区域，通常>= 1/2 Region Size，且只有 Full GC 阶段，才会回收 H 区，避免了频繁扫描、复制/移动大对象。

- 初始标记：仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改**TAMS（Nest Top Mark Start）\**的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要\**停顿线程**，但耗时很短。
- 并发标记：从GC Root 开始对堆中对象进行**可达性分析**，找到存活对象，此阶段耗时较长，但**可与用户程序并发执行**。
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在**线程的Remembered Set Logs**里面，最终标记阶段需要**把Remembered Set Logs的数据合并到Remembered Set中**，这阶段需要**停顿线程**，但是**可并行执行**。
- 筛选回收：首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

##### 2.4.3 CMS和G1的比较

1. CMS收集器是**获取最短回收停顿时间**为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会STW）。但**是CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降**。

2. CMS仅作用于老年代，是基于**标记清除算法**，所以清理的过程中**会有大量的空间碎片**。

3. CMS收集器**无法处理浮动垃圾**，**由于CMS并发清理阶段用户线程还在运行**，伴随程序的运行自然会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留在下一次GC时将其清理掉。

4. G1是一款面向服务端应用的垃圾收集器，**适用于多核处理器、大内存容量的服务端系统**。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU或核心来缩短STW的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。

5. **从JDK 9开始，G1成为默认的垃圾回收器**。当应用有以下任何一种特性时非常适合用G1：Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)。

6. G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region之间)属于复制算法。

7. G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 **G1 中维护记忆集的成本较高**，带来了更高的执行负载，影响效率。**所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB**。

   

### 3. 类加载机制

![JVM类加载机制](/Users/wenzhuowang/Desktop/框图/JVM类加载机制.png)

#### 3.1 类文件结构

##### 3.1.1 Java虚拟机的两个特性

1. 语言无关性

对于Java语言，我们通过编辑器编写的Java代码，后缀一般是.java。通过javac编译器编译后，会变成.class结尾的字节码文件，只有编译后的.class文件，才能在Java虚拟机上运行。

不管什么语言，只要能通过某种手段生成合乎规范的**.class字节码文件**，其实就可以在Java虚拟机上运行。

![img](https://img2018.cnblogs.com/blog/1120165/201909/1120165-20190902214020398-2130490371.png)



2. 平台无关性

一次编写，到处运行。在不同的系统下安装不同的Java虚拟机，程序能够在不同的系统上运行。

![img](https://img2018.cnblogs.com/blog/1120165/201909/1120165-20190902214614261-1530667755.png)



JVM指令集：字节码指令集



##### 3.1.2 常量池

![常量池](/Users/wenzhuowang/Desktop/框图/常量池.png)

| 类型         | 特点                                                         | 优点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 静态常量池   |                                                              | 为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享 |
| 运行时常量池 | 当.class文件被加载完成后，JVM会将静态常量池里的内容转移到运行时常量池里：<br />* 在静态常量池**不能被重写其他版本的符号引用是会被转变为直接引用**的，（比如说类的**静态方法或私有方法，实例构造方法，父类方法**）<br />* 其他的**一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的** |                                                              |
| 字符串常量池 | * 每当我们**使用字面量**（String s=“1”;）**创建字符串常量时**，JVM会首先检查字符串常量池：<br />如果该字符串已经存在常量池中，那么就将此字符串对象的地址赋值给引用s（引用s在Java栈）；<br />如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此字符串对象的地址赋值给引用s（引用s在Java栈中）。<br /> <br />* 每当我们**使用关键字new**（String s=new String(”1”);）**创建字符串常量时**，JVM会首先检查字符串常量池：<br />如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s；<br />如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s。 | 使JVM提高了性能和减少了内存开销                              |



#### 3.2 类加载过程

![类加载过程](https://camo.githubusercontent.com/de8ba784e91e417b9215a5e75dc5b068a38ff0c928a5746a9dc1f87ab18bcd4e/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d35413258494f2e706e67)

##### 3.2.1 加载

类加载过程的第一步，主要完成下面3件事情：

- 通过**全类名**获取定义此类的**二进制字节流**
- 将字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**
- 在内存中生成一个代表该类的 **Class 对象**,作为**方法区这些数据的访问入口**



##### 3.2.3 验证

- 文件格式验证：主要验证Class文件**是否规范**等。

- 元数据验证：对字节码描述的信息**语义分析**等。

- 字节码验证：确保**语义**是ok的。

- 符号引用验证：确保解析动作能执行。

  

##### 3.2.3 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

- 这时候进行内存分配的仅包括**类变量**（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。

- 这里所设置的初始值"通常情况"下是数据类型默认的**零值**（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 **fianl 关键字**`public static final int value=111` ，那么准备阶段 value 的值就被复制为 111。

  

##### 3.2.4 解析

解析阶段是虚拟机将常量池内的**符号引用替换为直接引用**的过程，也就是得到**类或者字段、方法在内存中的指针或者偏移量。**



##### 3.2.5 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 **Java 程序代码**(字节码)，初始化阶段是执行**类构造器** `<clinit> ()`方法的过程。



#### 3.3 类加载器

##### 3.3.1 三个类加载器

- BootstrapClassLoader(启动类加载器)：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
- ExtensionClassLoader(扩展类加载器)：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
- AppClassLoader(应用程序类加载器)



#### 3.4 类加载机制-双亲委派

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。

##### 过程

在类加载的时候，**系统会首先判断当前类是否被加载过**。已经被加载的类会直接返回，否则才会尝试加载。

加载的时候，**首先会把该请求委派该父类加载器**的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的**启动类加载器**中。

当父类加载器无法处理时，才**由自己来处理**。（当父类加载器为null时，会使用启动类加载器作为父类加载器。）

![类加载器](https://camo.githubusercontent.com/e1bcf49e6a732e8f66e1cce576661402f213b8f94471bba6ce41b34d24569964/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372542312542422545352538412541302545382542442542442545352539392541382d5a31576446742e706e67)



##### 好处

1. 保证了 **Java程序的稳定运行，可以避免类的重复加载**
2. 保证了 **Java 的核心 API 不被篡改**。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题。（比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。）

#####  [什么情况下需要开始类加载过程的第一个阶段加载](https://github.com/DreamCats/java-notes/blob/master/Java/classify/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md)

##### [如何打破双亲委派模型](https://github.com/DreamCats/java-notes/blob/master/Java/classify/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md)



### 4.对象创建过程

![Java创建对象的过程](https://camo.githubusercontent.com/a905ad4498d3d0837e9dcc1c23341d8137d77336dc2bf2b32abd69a70a14f49b/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f4a6176612545352538382539422545352542422542412545352541462542392545382542312541312545372539412538342545382542462538372545372541382538422d6643307752622e706e67)

![对象创建过程](/Users/wenzhuowang/Desktop/框图/对象创建过程.png)

#### 4.1 类加载检查

虚拟机遇到一条 **new** 指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的**类是否已被加载过**、**解析和初始化过**。如果没有，那必须先执行相应的类加载过程。

对象所需的内存大小在类加载完成后便可确定。

#### 4.2 分配内存

##### 4.2.1 两种方式（指针碰撞，空闲列表）

选择那种分配方式由 **Java 堆是否规整**决定，而 Java 堆是否规整又由**所采用的垃圾收集器是否带有压缩整理功能**决定。

##### 4.2.2 并发问题

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

- **TLAB：** 为**每一个线程预先在 Eden 区分配一块儿内存**，JVM 在给线程中的对象分配内存时，**首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配**

  

#### 4.3 初始化零值

内存分配完成后，虚拟机需要**将分配到的内存空间都初化为零值**（不包括对象头）。

这一步操作**保证了**对象的实例字段在 Java 代码中**可以不赋初始值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。

#### 4.4设置对象头

虚拟机要对对象进行必要的设置，相关信息放在对象头中

#### 4.5执行init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，**方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行**方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



#### 🐘 对象的布局

Hotspot JVM中，对象在内存中的布局包括3块区域：

对象头（header），对象实例数据（Instance Data）和对齐填充（Padding）。



#### 🐘 对象的访问方式

1. 句柄

如果使用句柄的话，那么 Java **堆中**将会划分出一块内存来作为**句柄池**，<u>reference 中存储的就是对象的句柄地址</u>，而句柄中包含了**对象实例数据**与**类型数据**各自的具体地址信息；

好处：使用句柄来访问的最大好处是 reference 中存储的是**稳定**的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 **reference 本身不需要修改**。

2. 直接指针

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <u>reference 中存储的直接就是对象的地址</u>。

好处：使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

![使用句柄-f4Cw9x](https://camo.githubusercontent.com/3501cb34812d6129ac468b95bf34579a76dcf5cb0fac5c22810bef4e96320c40/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545342542442542462545372539342541382545352538462541352545362539462538342d6634437739782e706e67)

![直接指针-8m3HHz](https://camo.githubusercontent.com/d584f6dda010a7bae95b34af5d39b00b4baf6b86dadfd21bc59cd80638f3263c/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f2545372539422542342545362538452541352545362538432538372545392539322538382d386d3348487a2e706e67)



### 5.逃逸分析

逃逸分析的基本行为就是分析**对象动态作用域**：

- **方法逃逸**：当一个对象在方法中被定义后，它可能被外部方法引用（例如作为调用参数传递到其他方法中）
- **线程逃逸**：甚至还有可能被外部线程访问到（例如赋值给类变量或可以在其他线程中访问的实例变量）

如果能证明**一个对象不会逃逸到方法或线程之外**，也就是**别的方法或线程无法通过任何途径访问到这个对象**，则可能为这个变量进行一些高效的优化：

1. **栈上分配**

Java虚拟机中，**如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存**将会是一个很不错的主意，**对象所占用的内存空间就可以随栈帧出栈而销毁**。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那**大量的对象就会随着方法的结束而自动销毁了**，垃圾收集系统的压力将会小很多。

2. **同步消除**

**线程同步本身是一个相对耗时的过程**，**如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问**，那这个变量的**读写肯定就不会有竞争**，对这个变量实施的同步措施也就可以消除。

3. **标量替换**

标量是指一**个数据已经无法再分解成更小的数据来表示了**，Java虚拟机的原始数据类型都不能再进一步分解，它们就可以称为标量。如果逃逸分析证明**一个对象不会被外部访问**，并且**这个对象可以被拆散的话**，那程序真正执行的时候将**可能不创建这个对象**，而改**为直接创建它的若干个被这个方法使用的成员变量来代替**。除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配到物理机器高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。

