# Java基础



### 1. 八大数据类型



### 2. 三大特性

Java 面向对象编程有三大特性：封装、继承、多态

#### 2.1 封装

目的：增强安全性和简化编程，（使用者不必了解具体的实现细节，而只要通过对外公开的访问方法，来使用类的成员）

基本要求：

- 把所有的属性私有化。
- 对每个属性提供 `getter` 和 `setter` 方法。
- 如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。
- 建议重写 `toString` 方法，但这不是必须的。



#### 2.2 继承

在一个现有类的基础之上，增加新的方法或**重写**已有方法，从而产生一个新类。

优点：给编程带来的好处就是对原有类的**复用**（重用）。除了继承之外，我们还可以使用**组合的方式**来复用类。增量开发的模式，提高开发效率，规避对原有代码的修改而带来的风险。

|       类型       | private  |  无修饰  | protected | public |
| :--------------: | :------: | :------: | :-------: | :----: |
|      同一类      |  可访问  |  可访问  |  可访问   | 可访问 |
|  同一包中的子类  | 不可访问 |  可访问  |  可访问   | 可访问 |
| 同一包中的非子类 | 不可访问 |  可访问  |  可访问   | 可访问 |
|  不同包中的子类  | 不可访问 | 不可访问 |  可访问   | 可访问 |
| 不同包中的非子类 | 不可访问 | 不可访问 | 不可访问  | 可访问 |

##### 2.2.1  Java中三种类

- 普通类：使用 `class` 定义且不含有抽象方法的类。
- 抽象类：使用 `abstract class` 定义的类，它可以含有或不含有抽象方法。
- 接口：使用 `interface` 定义的类。

继承规律：

- 普通类可以继承（`extends`）普通类，可以继承（`extends`）抽象类，可以继承（`implements`）接口。
- 抽象类可以继承（`extends`）普通类，可以继承（`extends`）抽象类，可以继承（`implements`）接口。
- 接口只能继承（`extends`）接口。

注意：

- 一个普通类/抽象类/接口，可以继承**任意多个**接口。

- 一个普通类继承一个抽象类/接口后，必须实现这个抽象类/接口中定义的所有抽象（`abstract`）方法/方法，否则就只能被定义为抽象类。

  

#### 2.3 多态

好处：消除了类之间的**耦合**关系，使程序更容易扩展。

实现多态的三个必要条件：

1. 继承：在多态中必须存在有继承关系的子类和父类。
2. 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
3. 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

##### 2.3.1 绑定

将一个方法调用同这个方法所属的主体（也就是对象或类）关联起来。

- 静态绑定：**在程序运行之前进行绑定**，由编译器和连接程序实现。比如 `static` 方法和 `final` 方法，注意，这里也包括 `private` 方法，因为它是隐式 `final` 的。
- 动态绑定/运行时绑定：**在运行时根据对象的类型进行绑定**，由方法调用机制实现。除了静态绑定外的所有方法都属于运行时绑定。

##### 2.3.2 实现

基于继承实现：继承都是**单继承**，只能为一组相关的类提供一致的服务接口。

基于接口实现：接口是**多继承多实现**，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。

##### 2.3.3 重载（overload）和重写（override）

- 重载：指在**同一个类**中定义了一个以上具有相同名称，但是型构不同的方法。（返回类型/参数类型/参数个数等）
- 重写：指在**继承**情况下，子类中定义了与其父类中方法具有相同型构的新方法，就称为子类把父类的方法重写了。这是实现多态必须的步骤。



### 3. 异常体系

![异常体系](/Users/wenzhuowang/Desktop/框图/异常体系.png)

#### 3.1 Error

Error描述了Java运行时**系统的内部错误**和**资源耗尽错误**，比如栈溢出和堆溢出。

##### 3.1.1 堆溢出（OutOfMemoryError）

- 虚拟机可动态扩展：扩展时无法申请到足够的内存
- 堆中没有内存完成实例分配，且虚拟机不可动态扩展

例子：无限创建线程。操作系统分配给每个进程内存是有限的，虚拟机提供了参数来控制堆和方法区的内存的最大值，而剩下的内存，忽略其他因素，就由虚拟机栈和本地方法栈“瓜分天下了”。**每个线程分配到栈容越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。**

##### 3.1.2 栈溢出（StackOverFlowError）

线程请求栈深度大于大于虚拟机允许的深度

例子：无限递归。每次调用方法所产生资源都存放在了虚拟机栈中，无限调用使得线程请求栈深度大于大于虚拟机允许的深度

![image-20210803205805676](/Users/wenzhuowang/Library/Application Support/typora-user-images/image-20210803205805676.png)



#### 3.2 Exception

1. RuntimeException（运行时）

2. 程序本身没有问题，由于像IO错误这类问题导致的异常（编译）



#### 3.3 受检异常和非受检异常

非受检异常：派生于**Error类或RuntimeException类**的所有异常

受检异常：所有其他的异常



#### 3.4 捕获异常

- `try` 块： 用于捕获异常。其后可接零个或多个`catch`块，如果没有`catch`块，则必须跟一个`finally`块。
- `catch` 块： 用于处理`try`捕获到的异常。
- `finally` 块： 无论是否捕获或处理异常，`finally`块里的语句都会被执行。当在`try`块或`catch`块中遇到`return`语句时，`finally`语句块将在方法返回之前被执行。



### 4. 泛型

类比模版类Template

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

**好处**：

- **类型安全**，提供编译期间的类型检测
- **前后兼容**
- **泛化代码,代码可以更多的重复利用**
- **性能较高**，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件



### 5. 反射机制

类的字节码文件对象(.class)

#### 5.1 什么是反射

🌟 在Java的反射机制中是指在**运行状态**中，对于任意一个类都能够知道这个类所有的**属性和方法**；并且对于任意一个对象，都能够调用它的**任意一个方法**；这种**动态获取信息以及动态调用对象方法**的功能成为 Java 语言的反射机制。

（1）核心：在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。

（2）本质：JVM得到类的字节码文件对象(.class)之后，再通过class对象进行反编译，从而获取对象的各种信息。

#### 5.2 过程

1. 执行创建A对象(new)时，触发JVM加载A的.class文件
2. JVM从本地磁盘找到.class文件，加载到JVM内存
3. JVM自动创建class对象（一个类只会产生一个class对象）
4. 通过class对象反响获取A对象的各种信息

#### 5.3 好处

Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。**通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。**

#### 5.4 反射的API

|                |                           |                                                              |
| :------------: | :-----------------------: | ------------------------------------------------------------ |
|    Class 类    |       反射的核心类        | 可以获取类的**属性，方法**等信息                             |
|    Field 类    | Java.lang.reflec 包中的类 | 表示类的成员变量，可以用来获取和设置类之中的**属性值**       |
|   Method 类    | Java.lang.reflec 包中的类 | 表示类的方法，它可以用来获取类中的**方法信息**或者**执行方法** |
| Constructor 类 | Java.lang.reflec 包中的类 | 表示类的构造方法                                             |

#### 5.5 获取class的方式

|  方式   | 例子&详解                                                    | 区别                                                         |
| :-----: | :----------------------------------------------------------- | ------------------------------------------------------------ |
|   new   | `Student student = new Student(); *// 这一new 产生一个Student对象，一个Class对象。*` | getClass() 的形式会对类进行**静态初始化**、**非静态初始化**，返回引用运行时<u>真正所指的对象</u>（因为子对象的引用可能会赋给父对象的引用变量中）<u>所属的类的 Class 对象</u> |
| .class  | `Class studentClass2 = Student.class; // 调用某个类的 class 属性来获取该类对应的 Class 对象` | 使 JVM 将使用类装载器将类装入内存（前提是类还没有装入内存），**不做类的初始化工作**，返回 Class 对象 |
| forname | `Class studentClass3 = Class.forName("com.reflect.Student") // 使用 Class 类中的 forName() 静态方法 ( 最安全 / 性能最好 )` | 装入类并做类的**静态初始化**，返回 Class 对象                |

#### 5.6 类加载器ClassLoader

遵循**双亲委派模型最终调用启动类加载器的类加载器**，实现的功能是“通过一个**类的全限定名来获取描述此类的二进制字节流**”，获取到二进制流后放到JVM中，加载的类**默认不会进行初始化**。

#### 5.7 反射都有哪些应用场景

Spring，Dubbo，RocketMQ这些优秀的框架背后都用到了反射

这说明，反射的优点之一灵活，提高了代码的灵活度；但同时性能受损，因为反射要进行一系列的解释操作。

### 6. 注解



### 7. Object



### 8. 集合类

